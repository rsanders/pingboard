/* 
 This file was generated by Dashcode.  
 You may edit this file to customize your widget or web page 
 according to the license.txt file included in the project.
 */

//
// Function: load()
// Called by HTML body element's onload event when the widget is ready to start
//
function load()
{
    dashcode.setupParts();
    
    setupPingFM();

    setupUI();
}

//
// Function: remove()
// Called when the widget has been removed from the Dashboard
//
function remove()
{
    // Stop any timers to prevent CPU usage
    // Remove any preferences as needed
    // widget.setPreferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
}

//
// Function: hide()
// Called when the widget has been hidden
//
function hide()
{
    // Stop any timers to prevent CPU usage
}

//
// Function: show()
// Called when the widget has been shown
//
function show()
{
    // Restart any timers that were stopped on hide
}

//
// Function: sync()
// Called when the widget has been synchronized with .Mac
//
function sync()
{
    // Retrieve any preference values that you need to be synchronized here
    // Use this for an instance key's value:
    // instancePreferenceValue = widget.preferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
    //
    // Or this for global key's value:
    // globalPreferenceValue = widget.preferenceForKey(null, "your-key");
}

//
// Function: showBack(event)
// Called when the info button is clicked to show the back of the widget
//
// event: onClick event from the info button
//
function showBack(event)
{
    var front = document.getElementById("front");
    var back = document.getElementById("back");

    if (window.widget) {
        widget.prepareForTransition("ToBack");
    }

    front.style.display = "none";
    back.style.display = "block";

    if (window.widget) {
        setTimeout('widget.performTransition();', 0);
    }
}

//
// Function: showFront(event)
// Called when the done button is clicked from the back of the widget
//
// event: onClick event from the done button
//
function showFront(event)
{
    var front = document.getElementById("front");
    var back = document.getElementById("back");

    if (window.widget) {
        widget.prepareForTransition("ToFront");
    }

    front.style.display="block";
    back.style.display="none";

    if (window.widget) {
        setTimeout('widget.performTransition();', 0);
    }
}

if (window.widget) {
    widget.onremove = remove;
    widget.onhide = hide;
    widget.onshow = show;
    widget.onsync = sync;
}


function openPingFM(event)
{
    widget.openURL("http://ping.fm/");
}


function getApiKey(event)
{
    widget.openURL("http://ping.fm/key/");
}


function postTextChange(event)
{
    var count = jQuery('#post_text').val().length;
    jQuery('#character_count').text(String(count));
}

var pingprefs = {
    setPref: function(key, value) {
        widget.setPreferenceForKey(value, key);
    },
    
    getPref: function(key, defval) {
        var res = widget.preferenceForKey(key);
        if (res == undefined) {
            return defval;
        } else {
            return res;
        }
    },
}

function setApiKey(value)
{
    pingprefs.setPref("pingfm_apikey", value);
}

function getApiKey()
{
    return pingprefs.setPref("pingfm_apikey");
}

function savePrefs()
{
    pingprefs.setPref("pingfm_apikey", pingview.getAppKey());
    pingprefs.setPref("debug", pingview.getDebug());
}

function configDone(event)
{
    savePrefs();
    setupPingFM();

    return showFront(event);
}


function populatePrefs()
{
    pingview.setAppKey(pingprefs.getPref("pingfm_apikey"));
    pingview.setDebug(pingprefs.getPref("debug"));
}

function doShowBack(event)
{
    populatePrefs();
    showBack(event);
}


function validateUser(event)
{
    // need to save prefs and setup Ping.FM first so we have the latest key
    savePrefs();
    setupPingFM();

    pingfm.validateUser();
}

var pingfm = {
   baseurl: "http://api.ping.fm/v1/",
   allowCache: true,
   api_key: null,
   user_app_key: null,
   debug: 0,
   post_method: 'default',
   
   getBaseArgs: function() {
     return { 
         api_key: this.api_key, 
         user_app_key: this.user_app_key,
         debug: this.debug
     };
   },
   
   validateUser: function() {
     var args = this.getBaseArgs();
     this.doRequest('user.validate', args, 
            function(data) {
                console.log("Success on user.validate");
                jQuery('#back_test_output').val("User is valid: " + jQuery('message', data).text());
            },
            function(data, error) {
                console.log("Failure on user.validate");
                jQuery('#back_test_output').val( error);
            }
        );
   },
   
   postMessage: function() {
     var args = this.getBaseArgs();
     args.post_method = this.post_method;
     args.body = jQuery('#post_text').val();

     this.doRequest('user.post', args, 
            function(data) {
                console.log("Success on user.post");
                jQuery('#back_test_output').val("Posting succeeded: " + jQuery('message', data).text());
            },
            function(data, error) {
                console.log("Failure on user.post");
                jQuery('#back_test_output').val( error);
            }
        );
   },

      doRequest: function(method, args, success, failure, httpmethod) {
        if (! httpmethod) {
          httpmethod = 'post';
        }

        var me = this;
        var request = jQuery.ajax({
          url: me.baseurl + method,
          type: httpmethod,
          data: args,
          global: true,
          cache: me.allowCache,
          success: this._makejQuerySuccessHandler(success, failure),
          error: this._makejQueryFailureHandler(failure)
        });
      },

  /**** Utility functions ****/

  _makejQuerySuccessHandler: function(success, failure) {
    var api = this;
    return function (data, status) {
      if (jQuery('rsp', data).attr('status') != 'OK')
      {
        console.log("status is bad");
        if (failure) {
          var errorText = jQuery('message', data).text();
          failure({ responseXML: data, responseText: "<error>" + errorText + "</error>" },
                  errorText, null);

        }
      }
      else
      {
        console.log("status is good");
        if (success) {
          success(data, status);
        }
      }
    };
  },

  _makejQueryFailureHandler: function(callback) {
    return function (response, status, error) {
      console.log("in hard failure");
      if (callback) {
        callback(response, "Hard failure: " + status, error);
      }
    };
  },
   
   foo: 'bar'
};

function setupPingFM()
{
    pingfm.api_key = '62efb891fc6ae7200a2699c566503735';
    pingfm.user_app_key = pingprefs.getPref('pingfm_apikey');
    pingfm.debug = pingprefs.getPref('debug', false) ? '1' : '0';
}


function doPost(event)
{
    pingfm.postMessage();
    pingview.setPostBody('');
}


function setPostType(event)
{
    console.log("set post type to " + event);
    console.log("this is " + this);
    console.log("item is " + this.value);
    pingfm.post_method = event.target.value;
}

var pingview = {
  getPostMethod: function() {
    return jQuery('select', jQuery('#post_type')).val();
  },
  
  setPostMethod: function(val) {
    jQuery('select', jQuery('#post_type')).val(val);
  },
  
  getPostBody: function() {
    return jQuery('#post_text').val();
  },
  
  setPostBody: function(val) {
    jQuery('#post_text').val(val);
  },
  
  getDebug: function() {
    return jQuery('#debug_button').get(0).checked;
  },
  
  setDebug: function(val) {
    jQuery('#debug_button').get(0).checked = val;
  },

  getAppKey: function() {
    return jQuery('#api_key').val();
  },
  
  setAppKey: function(val) {
    jQuery('#api_key').val(val);
  },
  
  version: '0.1',
};



function doDebugClick(event)
{
    pingfm.debug = pingview.getDebug() ? '1' : '0';
}

function setupUI()
{
    
}
